// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ===== USER MANAGEMENT & NEXTAUTH =====
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  image     String?
  emailVerified DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // User preferences
  theme            String @default("light") // light, dark
  defaultBookFormat String @default("6x9") // book size preference
  dailyWordGoal    Int    @default(500)

  // NextAuth relationships
  accounts Account[]
  sessions Session[]

  // Application relationships
  books           Book[]
  writingSessions WritingSession[]
  exports         Export[]
  researchSessions ResearchSession[]

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verificationtokens")
}

// ===== BOOK MANAGEMENT =====
model Book {
  id          String   @id @default(cuid())
  title       String
  description String?
  genre       String?
  targetWords Int?
  status      BookStatus @default(DRAFT)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Book formatting
  pageWidth   Float @default(6.0)   // inches
  pageHeight  Float @default(9.0)   // inches
  fontSize    Int   @default(12)
  fontFamily  String @default("Verdana")
  lineHeight  Float @default(1.5)
  marginTop   Float @default(0.7)
  marginBottom Float @default(1.0)
  marginLeft  Float @default(1.0)
  marginRight Float @default(1.0)

  // Chapter title formatting
  chapterTitleFontFamily String @default("Verdana")
  chapterTitleFontSize   Int    @default(26)
  chapterTitleAlignment  String @default("center") // left, center, right
  chapterTitlePadding    Int    @default(65)       // bottom spacing in pixels
  showChapterTitle       Boolean @default(true)

  // Cover
  coverImageUrl String?

  // Author
  userId String
  author User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Relationships
  chapters          Chapter[]
  brainstormingNotes BrainstormingNote[]
  characters        Character[]
  locations         Location[]
  plotPoints        PlotPoint[]
  timelineEvents    TimelineEvent[]
  researchItems     ResearchItem[]
  sceneCards        SceneCard[]
  writingSessions   WritingSession[]
  collaborators     BookCollaborator[]
  exports           Export[]
  versions          BookVersion[]
  
  // Research & Fact-checking (Non-fiction)
  researchResults   ResearchResult[]
  citations         Citation[]
  factChecks        FactCheck[]
  researchSessions  ResearchSession[]
  
  // Unified Vector Store
  embeddingChunks   BookEmbeddingChunk[]

  @@map("books")
}

model Chapter {
  id          String   @id @default(cuid())
  title       String
  description String?
  content     String   @default("") @db.Text // Full chapter content as continuous text
  orderIndex  Int
  wordCount   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Book relationship
  bookId String
  book   Book   @relation(fields: [bookId], references: [id], onDelete: Cascade)

  // AI Analysis
  lastGrammarCheck DateTime?
  grammarScore     Float?
  readabilityScore Float?
  paceScore        Float?
  embedding        Unsupported("vector(1536)")? // AI embedding for context

  // Audio/Audiobook
  audioUrl         String?   // S3 URL to the generated audio file
  audioS3Key       String?   // S3 key for the audio file
  audioDuration    Float?    // Duration in seconds
  audioGenerated   DateTime? // When audio was generated
  audioStatus      String    @default("not_generated") // not_generated, generating, completed, failed
  audioError       String?   // Error message if generation failed
  speakerName      String    @default("Alice") // Voice/speaker used for TTS

  // Relationships
  pages        Page[]
  sceneCards   SceneCard[]
  plotPoints   PlotPoint[]
  comments     Comment[]
  citations    Citation[]
  factChecks   FactCheck[]

  @@unique([bookId, orderIndex])
  @@map("chapters")
}

model Page {
  id         String   @id @default(cuid())
  pageNumber Int
  startPosition Int @default(0) // Character position where this page starts in chapter content
  endPosition   Int @default(0) // Character position where this page ends in chapter content
  wordCount  Int      @default(0)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Chapter relationship
  chapterId String
  chapter   Chapter @relation(fields: [chapterId], references: [id], onDelete: Cascade)

  // Relationships
  comments Comment[]

  @@unique([chapterId, pageNumber])
  @@map("pages")
}

// ===== BRAINSTORMING & IDEAS =====
model BrainstormingNote {
  id        String   @id @default(cuid())
  title     String
  content   String
  tags      String[] // Array of tags for categorization
  embedding Unsupported("vector(1536)")? // AI embedding for semantic search
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Book relationship
  bookId String
  book   Book   @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@map("brainstorming_notes")
}

// ===== CHARACTER & WORLD BUILDING =====
model Character {
  id          String   @id @default(cuid())
  name        String
  description String?
  appearance  String?
  personality String?
  backstory   String?
  role        CharacterRole @default(MINOR)
  imageUrl    String?
  embedding   Unsupported("vector(1536)")? // AI embedding for character context
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Character relationships
  relationships CharacterRelationship[] @relation("CharacterFrom")
  relatedTo     CharacterRelationship[] @relation("CharacterTo")

  // Book relationship
  bookId String
  book   Book   @relation(fields: [bookId], references: [id], onDelete: Cascade)

  // Timeline appearances
  timelineEvents TimelineEvent[]

  @@map("characters")
}

model CharacterRelationship {
  id           String @id @default(cuid())
  relationship String // "friend", "enemy", "family", "romantic", etc.
  description  String?

  characterFromId String
  characterFrom   Character @relation("CharacterFrom", fields: [characterFromId], references: [id], onDelete: Cascade)

  characterToId String
  characterTo   Character @relation("CharacterTo", fields: [characterToId], references: [id], onDelete: Cascade)

  @@unique([characterFromId, characterToId])
  @@map("character_relationships")
}

model Location {
  id          String   @id @default(cuid())
  name        String
  description String?
  geography   String?
  culture     String?
  rules       String?  // World-building rules
  imageUrl    String?
  embedding   Unsupported("vector(1536)")? // AI embedding for semantic search
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Book relationship
  bookId String
  book   Book   @relation(fields: [bookId], references: [id], onDelete: Cascade)

  // Timeline events in this location
  timelineEvents TimelineEvent[]

  @@map("locations")
}

// ===== PLOT STRUCTURE (7-Point System) =====
model PlotPoint {
  id          String    @id @default(cuid())
  type        PlotPointType
  title       String
  description String?
  orderIndex  Int
  completed   Boolean   @default(false)
  embedding   Unsupported("vector(1536)")? // AI embedding for semantic search
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Subplot categorization
  subplot     String?   // "main", "romance", "character", "action", etc.

  // Book relationship
  bookId String
  book   Book   @relation(fields: [bookId], references: [id], onDelete: Cascade)

  // Optional chapter relationship
  chapterId String?
  chapter   Chapter? @relation(fields: [chapterId], references: [id])

  @@unique([bookId, type, subplot])
  @@map("plot_points")
}

model TimelineEvent {
  id          String   @id @default(cuid())
  title       String
  description String?
  eventDate   String?  // In-story date/time (for display)
  startTime   Int      // Start time unit (integer)
  endTime     Int      // End time unit (integer)
  orderIndex  Int
  embedding   Unsupported("vector(1536)")? // AI embedding for semantic search
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Book relationship
  bookId String
  book   Book   @relation(fields: [bookId], references: [id], onDelete: Cascade)

  // Optional relationships
  characterId String?
  character   Character? @relation(fields: [characterId], references: [id])

  locationId String?
  location   Location? @relation(fields: [locationId], references: [id])

  @@map("timeline_events")
}

model SceneCard {
  id          String   @id @default(cuid())
  title       String
  description String?
  purpose     String?  // Scene's purpose in the story
  conflict    String?  // Main conflict in the scene
  outcome     String?  // Scene outcome
  orderIndex  Int
  wordCount   Int      @default(0)
  status      SceneStatus @default(PLANNED)
  embedding   Unsupported("vector(1536)")? // AI embedding for semantic search
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Book relationship
  bookId String
  book   Book   @relation(fields: [bookId], references: [id], onDelete: Cascade)

  // Optional chapter relationship
  chapterId String?
  chapter   Chapter? @relation(fields: [chapterId], references: [id])

  @@map("scene_cards")
}

model ResearchItem {
  id          String   @id @default(cuid())
  title       String
  content     String?
  url         String?
  imageUrl    String?
  tags        String[] // Array of tags
  itemType    ResearchType @default(NOTE)
  embedding   Unsupported("vector(1536)")? // AI embedding for semantic search
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Book relationship
  bookId String
  book   Book   @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@map("research_items")
}

// ===== WRITING STATISTICS & GOALS =====
model WritingSession {
  id         String   @id @default(cuid())
  startTime  DateTime
  endTime    DateTime?
  wordsWritten Int    @default(0)
  targetWords  Int?
  notes      String?
  completed  Boolean  @default(false)

  // User relationship
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Optional book relationship
  bookId String?
  book   Book?   @relation(fields: [bookId], references: [id])

  @@map("writing_sessions")
}

// ===== COLLABORATION =====
model BookCollaborator {
  id        String   @id @default(cuid())
  email     String
  role      CollaboratorRole
  inviteStatus InviteStatus @default(PENDING)
  invitedAt DateTime @default(now())
  joinedAt  DateTime?

  // Book relationship
  bookId String
  book   Book   @relation(fields: [bookId], references: [id], onDelete: Cascade)

  // Comments by this collaborator
  comments Comment[]

  @@unique([bookId, email])
  @@map("book_collaborators")
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  resolved  Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Author of comment
  collaboratorId String
  collaborator   BookCollaborator @relation(fields: [collaboratorId], references: [id], onDelete: Cascade)

  // Optional relationships (comment can be on page or chapter)
  pageId    String?
  page      Page?    @relation(fields: [pageId], references: [id])

  chapterId String?
  chapter   Chapter? @relation(fields: [chapterId], references: [id])

  @@map("comments")
}

// ===== VERSION CONTROL =====
model BookVersion {
  id          String   @id @default(cuid())
  version     String   // "1.0", "1.1", etc.
  description String?
  snapshot    Json     // Complete book data snapshot
  createdAt   DateTime @default(now())

  // Book relationship
  bookId String
  book   Book   @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@map("book_versions")
}

// ===== EXPORT & PUBLISHING =====
model Export {
  id        String     @id @default(cuid())
  format    ExportFormat
  fileName  String
  fileUrl   String?
  status    ExportStatus @default(PROCESSING)
  settings  Json?      // Export-specific settings
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  // User relationship
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Book relationship
  bookId String
  book   Book   @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@map("exports")
}

// ===== ENUMS =====
enum BookStatus {
  DRAFT
  IN_PROGRESS
  FIRST_DRAFT_COMPLETE
  EDITING
  BETA_READING
  FINAL_DRAFT
  PUBLISHED
}

enum CharacterRole {
  PROTAGONIST
  ANTAGONIST
  MAJOR
  MINOR
  CAMEO
}

enum PlotPointType {
  HOOK
  PLOT_TURN_1
  PINCH_1
  MIDPOINT
  PINCH_2
  PLOT_TURN_2
  RESOLUTION
}

enum SceneStatus {
  PLANNED
  DRAFT
  REVISED
  COMPLETE
}

enum ResearchType {
  NOTE
  LINK
  IMAGE
  DOCUMENT
  VIDEO
}

enum CollaboratorRole {
  BETA_READER
  EDITOR
  CO_AUTHOR
  VIEWER
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum ExportFormat {
  PDF
  TXT
  HTML
  MP3
}

enum ExportStatus {
  PROCESSING
  COMPLETED
  FAILED
}

// ===== NON-FICTION RESEARCH & FACT-CHECKING =====

enum ResearchSource {
  WIKIPEDIA
  SCHOLARLY
  NEWS
  GOVERNMENT
  BOOKS
  CUSTOM
}

enum CitationFormat {
  APA
  MLA
  CHICAGO
}

enum FactCheckStatus {
  VERIFIED
  DISPUTED
  UNCERTAIN
  REQUIRES_REVIEW
}

// Store research results from external sources
model ResearchResult {
  id               String         @id @default(cuid())
  bookId           String
  query            String         @db.VarChar(500)
  title            String         @db.VarChar(500)
  summary          String?        @db.Text
  content          String?        @db.Text
  sourceType       ResearchSource
  sourceUrl        String?        @db.VarChar(1000)
  credibilityScore Int            @default(0)
  authors          String[]       @default([])
  tags             String[]       @default([])
  imageUrl         String?        @db.VarChar(1000)
  publishedAt      DateTime?
  lastUpdated      DateTime       @default(now())
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  
  // AI embedding for semantic search
  embedding        Unsupported("vector(1536)")?
  
  // Relationships
  book             Book           @relation(fields: [bookId], references: [id], onDelete: Cascade)
  citations        Citation[]
  factChecks       FactCheck[]
  
  @@index([bookId])
  @@index([sourceType])
  @@index([credibilityScore])
}

// Manage citations and bibliography
model Citation {
  id               String          @id @default(cuid())
  bookId           String
  researchResultId String?
  chapterId        String?
  claimText        String?         @db.Text
  format           CitationFormat
  citationText     String          @db.Text
  bibliographyEntry String         @db.Text
  pageNumber       Int?
  inlineLocation   String?         @db.VarChar(200) // e.g., "Chapter 3, paragraph 2"
  notes            String?         @db.Text
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  
  // Relationships
  book             Book            @relation(fields: [bookId], references: [id], onDelete: Cascade)
  researchResult   ResearchResult? @relation(fields: [researchResultId], references: [id], onDelete: SetNull)
  chapter          Chapter?        @relation(fields: [chapterId], references: [id], onDelete: SetNull)
  
  @@index([bookId])
  @@index([format])
  @@index([chapterId])
}

// Fact-checking results for claims
model FactCheck {
  id                    String           @id @default(cuid())
  bookId                String
  chapterId             String?
  researchResultId      String?
  claim                 String           @db.VarChar(1000)
  status                FactCheckStatus
  confidenceScore       Int              @default(0) // 0-100
  verificationSources   Json             @default("[]") // Array of source URLs/titles
  conflictingSources    Json?            @default("[]") // Sources that contradict
  recommendations       String?          @db.Text
  verifiedBy            String?          @db.VarChar(100) // e.g., "AI Assistant", "Manual Review"
  reviewedAt            DateTime?
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @updatedAt
  
  // Relationships
  book                  Book             @relation(fields: [bookId], references: [id], onDelete: Cascade)
  chapter               Chapter?         @relation(fields: [chapterId], references: [id], onDelete: SetNull)
  researchResult        ResearchResult?  @relation(fields: [researchResultId], references: [id], onDelete: SetNull)
  
  @@index([bookId])
  @@index([status])
  @@index([confidenceScore])
}

// Store research queries and sessions for analytics
model ResearchSession {
  id           String   @id @default(cuid())
  bookId       String
  userId       String
  query        String   @db.VarChar(500)
  resultsCount Int      @default(0)
  sourcesUsed  String[] @default([]) // e.g., ["wikipedia", "scholarly"]
  duration     Int?     // milliseconds
  successful   Boolean  @default(true)
  createdAt    DateTime @default(now())
  
  // Relationships
  book         Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([bookId])
  @@index([userId])
  @@index([createdAt])
  @@map("research_sessions")
}

// ===== UNIFIED VECTOR STORE =====
// Stores chunked embeddings for all book content with source tracking
model BookEmbeddingChunk {
  id          String   @id @default(cuid())
  bookId      String
  book        Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  
  // Source tracking - what content this chunk came from
  sourceType  String   // 'chapter', 'brainstorming', 'character', 'location', 'plotPoint', 'timeline', 'sceneCard', 'research'
  sourceId    String   // ID of the source entity
  chunkIndex  Int      @default(0) // For splitting large content into multiple chunks
  
  // Content and metadata
  content     String   @db.Text // The actual text chunk (500-1000 chars)
  metadata    Json     // Store title, orderIndex, chapter number, character name, etc. for display
  
  // Vector embedding (OpenAI ada-002: 1536 dimensions)
  embedding   Unsupported("vector(1536)")? // pgvector format
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([bookId, sourceType])
  @@index([bookId, sourceId])
  @@map("book_embedding_chunks")
} 